<!DOCTYPE html>
<html>

<head>
	<style type="text/css">
		html,
		body {
			/*font-family: georgia,times,serif;*/
			/*font-family: athelas,georgia,serif;*/
			font-family: monospace;
			color: #FFFFCC;
			background: rgb(0, 0, 0) url("../banner.png") no-repeat;
			background-size: 100%;
			background-attachment: fixed;
			padding: 0px;
			margin: 0px;
		}
		a {
			color: #FFFFCC;
		}
		.shadowedtext {
			text-shadow: rgb(0, 0, 0) 1px 0 20px;
		}
		.mainbody {
			background: rgb(25, 25, 25);
		}
		.myalignleft {
			text-align: left;
		}
		.mycolumn40 {
			float: left;
			width: 40%;
			padding: 7px;
		}
		.mycolumn20 {
			float: left;
			width: 23%;
			padding: 7px;
		}
		.myrow::after {
			content: "";
			clear: both;
			display: table;
		}

	</style>
</head>

<body>
	<br>
	<center><h1 class="shadowedtext">Eero Mutka</h1></center>
	<center><h2 class="shadowedtext">Game Programmer</h2></center>
	<br>
	<div class="mainbody">
		<hr color="gray">
		<center>
		<a href="../index.html"><big>Home</big></a> |
		<a href="https://www.linkedin.com/in/eero-mutka/"><big>Linkedin</big></a> |
		<a href="https://www.youtube.com/@eeromutka186"><big>Youtube</big></a> |
		<a href=https://mastodon.gamedev.place/@EeroMutka"><big>Mastodon</big></a>
		</center>
		<hr color="gray">
		
		<center>
		<br>
		<h1>Immediate-mode UI library</h1>
		</center>
		
		<div style="text-align: center;">
		<div style="display: inline-block; width: 50%; text-align: left; font-size: large;">
			
			<p>Over time, I've built up a library to easily make user interfaces in my projects. This is a small showcase of it and a description of how it's implemented.</p>
			
			<br>
			<iframe width="100%" height="400" src="https://www.youtube.com/embed/f_GKB4jV1Cs""></iframe>

			<p>When I started out making projects with C++, I used the <a href="https://github.com/ocornut/imgui">Dear Imgui</a> library. It's a joy to use thanks to its immediate-mode API where you rebuild the UI every frame. Soon it became clear that I wanted more control and wanted to build something similar on my own.</p>

			<p>My other projects have been the driving force for requiring UI, and as such I've been building the UI code slowly over time and it has went through a lot of iteration. It's pretty easy to get started with UIs by just drawing some rectangles and detecting if the mouse is inside them, but when I started adding a layout system for convenience and more controls on top, the system easily became tangled with interdependencies that made building more complicated UIs difficult. Keeping the system simple and extendable has been the main challenge, and it wasn't obvious to me in the beginning how to do that.</p>

			<h2>Implementation</h2>

			<p>The basic idea of immediate-mode UIs is to rebuild the entire user interface every frame. The classic alternative to this is retained-mode UIs, where the UI library defines a hierarchy of unique widget types, typically as a C++ class hierarchy. In retained mode UIs, the user is responsible for then creating and managing these objects and sending events between them, such as "add a child widget to a menu" or "attach on-pressed callback for this button". Immediate-mode style is a lot more convenient, because it doesn't require the user to manage extra state explicitly; instead, the user can generate the UI directly from their own internal program state in one pure data transformation. A great source of inspiration has been <a href="https://www.rfleury.com/p/ui-series-table-of-contents">Ryan Fleury's UI articles</a>.</p>

			<p>As the basis of my UI system, you build up hierarchical trees of "UI boxes" that get placed one after another vertically or horizontally. A box is just a rectangle with a group of behaviours, such as "has text", "draw border", "add padding to child boxes", and so on. So, for example, adding a button to the UI might be a call to an "Add Box" function with the behaviours "has text", "clickable", "draw border" and "draw solid color". The main benefit of having a tree structure is the convenient layout and sizing system. When adding a box, you specify a width and a height, each containing a few parameters which define how big of a size the box will be given. You can specify a size in pixels, or as a "minimal fit", or as "flex, taking as much free space as possible". The UI then has a function to compute all the rectangles for the box tree when the tree has been generated by the user. Another advantage of this structure is is that the UI system will know the relationships of these boxes and can use it to implement keyboard navigation that requires no extra work by the user.</p>

			<h2>Generating Unique Keys</h2>

			<p>Another common trope of immediate-mode UIs is that they give back information about user-interaction *immediately* when you're building the UI. For example, in Dear Imgui you can call `ImGui::Button()`, which returns a boolean that says if it has been pressed. It means that code which is logically related to that button can be implemented right then and there, which is nice. However, my UI system performs smart layouting which means that when adding a box to the tree, its rectangle cannot be calculated yet, because its size may depend on the sizes of other boxes in the tree which may not have been added yet. And so, which rectangle can we even check against when figuring out if a box has been pressed? The trick is to give each UI box an unique "key" that identifies it across frames. This can be calculated using many ways, for example by hashing the button text, as Dear Imgui does. I have a slightly different method which I'll explain shortly. But so, if we store some data from the previous frame, such as the rectangles of all boxes, we can look up the rectangle of the box from the previous frame using this unique key and use that to check for mouse overlap! For UI elements which don't move across frames, there won't be any extra frame of latency with this method. If you do have lots of fast moving UI elements that need clicking... there may be bigger UI issues to fix first.</p>

			<p>A nice way to implement caching for the previous frame (and to manage memory in general) is to use <a href="https://www.gingerbill.org/article/2019/02/08/memory-allocation-strategies-002">arenas</a>. My UI system currently stores the entire UI tree of the previous frame, so we have a lot of data at our hands if needed. The way to do this efficiently with arenas is to have two of them: on frame 1, build the UI tree on arena A, then on frame 2 build the UI tree on arena B and use arena A as the previous frame's cache, then continue switching between the two arenas. At each frame, we also build a hash map from key -> box pointer, which stores the box data for that particular frame and pointers to its related nodes in the tree (prev/next/parent/children). The approach I took for coming up with unique keys for the boxes is to let the user do it, but to provide helpful macros for it. You can call `UI_KEY()`, which gives you an unique key for that particular macro usage site, and is enough in a lot of cases. You can also hash keys together, i.e. `UI_KEY1(key_a)` or `UI_KEY2(key_a, key_b)`, which both generate a unique key taking other keys and the macro usage site into account. You may also hash your own data such as integers into keys to make new keys. If the same key appears twice during a frame, I assert to let the user know they messed up. This method has worked really well for me.</p>

			<h2>Drawing</h2>

			<p>The second part of the UI system is the drawing code. I really like how Dear Imgui has an easy-to-use API for drawing functions like "Add Rectangle", "Add Circle", "Add Text", and so on. I wanted to follow a similar route. From a high level view, after the rectangles have been generated for a tree, the user can call "Draw Box" on the tree root box, which will recursively call these drawing functions for each box. The user can also call these drawing functions directly at any point if they want to hand-roll some UI code and to bypass the box tree system altogether. Having every possible behaviour and layouting option imaginable in the box tree system isn't realistic (or desirable), so being able to opt out of it is nice.</p>

			<p>How the drawing functions are implemented has also gone through some iteration. At one point I was following a similar system to Ryan's, where rectangles are submitted to the GPU and then rendered using signed distance functions with parameters for edge roundness, softness, thickness, etc. I also defined a few other shapes like circles. I then decided to scrap it in favour of Dear Imgui-style rendering, where you submit a dumb vertex buffer, where each vertex has a position and a color and optionally a texture. This approach is more limiting and means that you have to generate the geometry on the CPU, but because of this it's also more flexible. It means that the user can look at the provided drawing functions, copy code from it, make variations, and do whatever they like, all without looking at or touching any shader code. This is nice, because similarly to Dear IMGUI, I want it to be easy to swap rendering backends or to provide your own.</p>

			<p>You can find the UI library and the demo program here: <a href="https://github.com/EeroMutka/Fire">https://github.com/EeroMutka/Fire</a></p>
			
			<br>
			<br>
			<iframe width="100%" height="400" src="https://www.youtube.com/embed/UjjCEtLgICU""></iframe>
			<i>A short peek into a recent project I've been working on using the UI system. You can see me fiddling around in the log window, because I was happy I implemented 2-way scrollbars</i><br><br>
			
		</div>
		</div>

		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		
	</div>

</body>

</html>