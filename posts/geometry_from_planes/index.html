<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Generating a 3D mesh from a list of scissor-planes | Eero&#39;s blog</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Recently I started a new project of making a real-time 3D editor, using CSG (constructive solid geometry). I didn&rsquo;t exactly know how CSG worked before, so I looked into some articles. I learned some cool things, such as what the half-edge data structure is. Previously, it had been a big mystery to me how you would actually implement a 3d modeling operation such as extrusion, bevel, or inserting edge loops, but this small idea really opened things up for me.">
    <meta name="generator" content="Hugo 0.112.6">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    
    
    
      

    

    
    
    <meta property="og:title" content="Generating a 3D mesh from a list of scissor-planes" />
<meta property="og:description" content="Recently I started a new project of making a real-time 3D editor, using CSG (constructive solid geometry). I didn&rsquo;t exactly know how CSG worked before, so I looked into some articles. I learned some cool things, such as what the half-edge data structure is. Previously, it had been a big mystery to me how you would actually implement a 3d modeling operation such as extrusion, bevel, or inserting edge loops, but this small idea really opened things up for me." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://eeromutka.github.io/posts/geometry_from_planes/" /><meta property="article:section" content="posts" />


<meta itemprop="name" content="Generating a 3D mesh from a list of scissor-planes">
<meta itemprop="description" content="Recently I started a new project of making a real-time 3D editor, using CSG (constructive solid geometry). I didn&rsquo;t exactly know how CSG worked before, so I looked into some articles. I learned some cool things, such as what the half-edge data structure is. Previously, it had been a big mystery to me how you would actually implement a 3d modeling operation such as extrusion, bevel, or inserting edge loops, but this small idea really opened things up for me.">

<meta itemprop="wordCount" content="1376">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Generating a 3D mesh from a list of scissor-planes"/>
<meta name="twitter:description" content="Recently I started a new project of making a real-time 3D editor, using CSG (constructive solid geometry). I didn&rsquo;t exactly know how CSG worked before, so I looked into some articles. I learned some cool things, such as what the half-edge data structure is. Previously, it had been a big mystery to me how you would actually implement a 3d modeling operation such as extrusion, bevel, or inserting edge loops, but this small idea really opened things up for me."/>

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Eero&#39;s blog
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/" title="Posts page">
              Posts
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/portfolio/" title="Portfolio page">
              Portfolio
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white no-underline white-90" href="/contact/" title="Contact page">
              Contact
            </a>
          </li>
          
        </ul>
      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked">
          
        POSTS
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">Generating a 3D mesh from a list of scissor-planes</h1>
      
      
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Recently I started a new project of making a real-time 3D editor, using CSG (constructive solid geometry). I didn&rsquo;t exactly know how CSG worked before, so I looked into <a href="http://sandervanrossen.blogspot.com/2009/12/realtime-csg-part-1.html">some articles</a>. I learned some cool things, such as what the half-edge data structure is. Previously, it had been a big mystery to me how you would actually implement a 3d modeling operation such as extrusion, bevel, or inserting edge loops, but this small idea really opened things up for me. It&rsquo;s all so clear now! You should first <a href="https://www.flipcode.com/archives/The_Half-Edge_Data_Structure.shtml">read about it</a> if you&rsquo;re not familiar with it. You can easily convert a half-edge mesh to a traditional triangle-mesh that you&rsquo;d feed to the GPU for instance.</p>
<p><em>TIP: Instead of storing half-edges separately, I&rsquo;m bundling them together in a single Edge-struct that stores both of them. This way we need one less pointer to worry about. Also, if we want to store data that is shared per each edge, such as sharpness/smoothness or determining a UV-seam, it can be stored right there in one place. A half-edge index is the edge index in the first 31 bits and the last bit indicating it&rsquo;s the first or the second half.</em></p>
<p>One neat idea suggested in the articles is how brushes are not defined by a mesh, but by a list of planes that each cut the space in half. It should then be easier to perform boolean operations with this lists of planes than with arbitrary triangle meshes. I&rsquo;m currently on the <a href="http://sandervanrossen.blogspot.com/2009/12/realtime-csg-part-2.html">second part of the real-time CSG blog</a>, which presents two methods for converting a list of planes into a 3d mesh. The first &ldquo;widely used&rdquo; method is to project a huge axis-aligned rectangle per each cut-plane to form a polygon, then slice that polygon per each plane, and finally merge all of the vertices. My initial thoughts align with the author in that this doesn&rsquo;t seem very elegant. We&rsquo;d have to decide on a &ldquo;big value&rdquo; that covers everything. Is there a maximum value where the math starts breaking due to floating point errors? And, we&rsquo;d have to use epsilons for floating point comparisons for vertex-merging, and having to merge vertices is a bit ananoying in the first place.</p>
<p><em>TIP: Instead of storing 3d planes as point + normal, store them by their mathematical coefficients ax + by + cz + d = 0, where [a, b, c] represent the normal and &rsquo;d&rsquo; the signed distance of the origin from the plane. It&rsquo;s less data and less useless degrees of freedom, which is always good to minimize. Calculating the distance of a point to the plane is simply  dot(point, plane.normal) - plane.d</em></p>
<p>The second, &ldquo;precise&rdquo;, method is to loop through all combinations of plane-triples to find the intersection vertices (that are also inside the object), then generate geometry from that. My code for this looked something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> planes_count <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>	Plane plane_i <span style="color:#f92672">=</span> planes[i];
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> planes_count <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>			Plane plane_j <span style="color:#f92672">=</span> planes[j];
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&lt;</span> planes_count; k<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>				Plane plane_k <span style="color:#f92672">=</span> planes[k];
</span></span><span style="display:flex;"><span>				
</span></span><span style="display:flex;"><span>				Vector3 p;
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>intersection_point_three_planes(plane_i, plane_j, plane_k, <span style="color:#f92672">&amp;</span>p))
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>				
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// We want to ignore vertices that lie outside the object.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// To determine whether this vertex is outside the object, we must loop
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// through the planes once more; the vertex is outside if there&#39;s even one
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// plane that the vertex is on the positive side on.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">bool</span> vertex_is_outside_the_object <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> l <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; l <span style="color:#f92672">&lt;</span> planes_count; l<span style="color:#f92672">++</span>) { <span style="color:#75715e">// so much N!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">if</span> (l <span style="color:#f92672">==</span> i <span style="color:#f92672">||</span> l <span style="color:#f92672">==</span> j <span style="color:#f92672">||</span> l <span style="color:#f92672">==</span> k) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>				
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> (dot(p, planes[l].abc) <span style="color:#f92672">+</span> planes[l].d <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.0001f</span>) {
</span></span><span style="display:flex;"><span>					<span style="color:#75715e">// The vertex is on the positive side of the plane and thus outside the object.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>					<span style="color:#75715e">// Note the annoying epsilon - if we didn&#39;t have it, some vertices could get
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>					<span style="color:#75715e">// completely removed in intersection points with &gt;3 planes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>					vertex_is_outside_the_object <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> (vertex_is_outside_the_object) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>			<span style="color:#75715e">// Add the vertex to an array of vertices. Note that a vertex can have more than three planes going
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// through it, so we need the ability to merge the vertices. In my code, I stored the vertex positions
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			<span style="color:#75715e">// as three integers, so I could hash the coordinates and use a hash-table to quickly merge vertices.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>			...
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>While implementing it, I was aware of how O(n^a_lot) this was, but only after implementing I looked back at it and said, &ldquo;Yeah, that&rsquo;s too exponential.&rdquo; And we didn&rsquo;t even get to generating the faces/edges yet, we only did the first step of getting the vertices. I&rsquo;m not entirely sure if going through all combinations of plane-triples is how you&rsquo;re supposed to do it, but this is what I interpreted the article was suggesting.</p>
<p>I started thinking about why the &ldquo;clean&rdquo; solution is more computation work than the first one, which is <em>only</em> O(n^2), where <em>n</em> is the number of planes. Looking at a sketch I made, it&rsquo;s clear that when adding a line (or a plane in 3d), we will have to intersect it with every single other line (even worse in 3d) and the vast majority of intersection points will be outside the object and unnecessary work:</p>
<p><img src="lots_of_verts.png" alt="Image alt"></p>
<p>Maybe we could keep some kind of bounding box that we would shrink with each plane and discard planes and vertices that lie outside it? This starts sounding pretty complex. I looked into known methods for solving the <a href="https://en.wikipedia.org/wiki/Vertex_enumeration_problem">vertex enumeration problem</a>, such as <a href="https://link.springer.com/chapter/10.1007/3-540-61576-8_77">this</a> &ldquo;simple&rdquo; and <a href="http://cgm.cs.mcgill.ca/~avis/doc/avis/AF92b.pdf">this</a> &ldquo;extremely simple&rdquo; algorithm. I disagree with their definitions of simple.</p>
<p>I was nearly finished with implementing the dumb projected-rectangle method until it hit me: the key to being fast is to try to eliminate possible intersections as early as possible. So, if I just started with a cube and cut it with each plane step by step, we wouldn&rsquo;t have the same kind of exponential explosion as the previous methods! I&rsquo;d need an algorithm for cutting a mesh by a plane, but I realized that I&rsquo;d likely need something similar later anyway, so I started implementing it. Once I have that, I could just hand-craft the data structure for the starting cube, scale it up a lot, and start cutting!</p>
<p><img src="cube_half_edge_ref.png" alt="Image alt">
<em>A crucial help for debugging was to make a reference image of mr. base-cube. I&rsquo;ve become good friends with him.</em></p>
<h2 id="how-to-cut-a-mesh-by-a-plane">How to cut a mesh by a plane?</h2>
<p>My algorithm for this is quite simple: start by finding <strong>any</strong> edge that intersects the plane and deleting all of the faces that lie completely outside the plane. Then start going around one of its faces until you hit another intersecting (half) edge. Split both of these edges in two and connect them by an edge. Then hop into another side of the latter half-edge and repeat until you&rsquo;re back at the start. We&rsquo;re effectively traveling in a circle around the mesh using the linked nature of the data structure, splitting each edge in half as we go.</p>
<p>This is a lot faster than any of the previously discussed methods. Per each plane, the worst case is you need to loop through all the existing geometry once as opposed to all of the other planes. The method is also as stable as it can be, as it doesn&rsquo;t involve any epsilons. Hooray!</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/EghUcSJ1qrg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<p>Stability is a big reason why I chose to explore CSG. Arbitrary mesh-vs-mesh booleans seem very difficult to program well. You can see this in action if you try to boolean two complicated meshes together in any 3D tool like blender/maya. Or, if the boolean&rsquo;d meshes have sides that barely touch, you can expect troubles. They have a reputation for being a bit wonky in general. It makes sense, as there isn&rsquo;t even an obvious answer to how they should behave in certain cases. What should happen if you boolean a mesh with holes and flying geometry with another? When we stick to the constraint that at least one of them has to be a convex mesh defined by planes, everything is a lot more intuitive. I want to avoid corner cases where things break in my editor. So far this seems plausable, wish me luck!</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://eeromutka.github.io/" >
    &copy;  Eero's blog 2023 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
